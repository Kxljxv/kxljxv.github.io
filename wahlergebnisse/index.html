<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>Berlin Wahlergebnisse Karte</title>
  <!-- Maplibre GL JS -->
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* White Mode, Pastellfarben, modernes Responsive Design */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background-color: #fff;
      color: #333;
    }
    #controls {
      padding: 10px;
      background-color: #f7f7f7;
      border-bottom: 1px solid #ddd;
    }
    #controls label {
      margin-right: 5px;
    }
    #controls select {
      margin-right: 15px;
      padding: 3px 5px;
    }
    /* Container für Karte und Diagramm */
    #content {
      display: flex;
      flex-direction: row;
      height: calc(100vh - 60px);
    }
    /* Im Landscape-Modus: Karte links, Diagramm rechts */
    .landscape #map {
      flex: 2;
    }
    .landscape #chartContainer {
      flex: 1;
      border-left: 1px solid #ddd;
      padding: 10px;
    }
    /* Im Hochformat (Portrait): Diagramm unter der Karte */
    .portrait #content {
      flex-direction: column;
    }
    .portrait #map {
      height: 60%;
    }
    .portrait #chartContainer {
      height: 40%;
      border-top: 1px solid #ddd;
      padding: 10px;
    }
    /* Karte füllt den Container */
    #map {
      position: relative;
    }
    /* Infozeile über dem Diagramm */
    #chartInfo {
      text-align: center;
      margin-bottom: 5px;
      font-weight: bold;
    }
  </style>
</head>
<body class="landscape">
  <!-- Steuerung: Wahljahr, Ergebnissart, Anzeige-Modus -->
  <div id="controls">
    <label for="wahljahr">Wahljahr:</label>
    <select id="wahljahr">
      <option value="2021">2021</option>
      <option value="2025">2025</option>
    </select>
    
    <label for="ergebnissart">Ergebnissart:</label>
    <select id="ergebnissart">
      <option value="gewinner">Gewinner</option>
      <!-- Beispielhafte weitere Spalten – bitte nach Bedarf erweitern -->
      <option value="21WAHLBETEILIGUNG">21 Wahlbeteiligung</option>
      <option value="21AFD">21 AFD</option>
      <option value="21GRUENE">21 Grüne</option>
      <option value="25WAHLBETEILIGUNG">25 Wahlbeteiligung</option>
      <option value="25VOLT">25 Volt</option>
    </select>
    
    <label for="mode">Darstellungsmodus:</label>
    <select id="mode">
      <option value="landscape">Landscape</option>
      <option value="portrait">Hochformat</option>
    </select>
  </div>

  <!-- Hauptinhalt: Karte und Diagramm -->
  <div id="content">
    <div id="map"></div>
    <div id="chartContainer">
      <div id="chartInfo">
        <span id="districtID">Berlin</span> – <span id="bezirkName">Gesamt</span>
      </div>
      <canvas id="barChart"></canvas>
    </div>
  </div>

  <!-- JavaScript -->
  <script>
    /********************
     * Konfigurationen *
     ********************/
    // Für jede Spalte in der CSV definieren wir:
    // Gewinnerfarbe, Minimalfarbe, Maximalfarbe, Minimal- und Maximalwert sowie eine Darstellungsfarbe.
    const columnConfig = {
      "21WAHLBETEILIGUNG": { winnerColor: "#1f77b4", minColor: "#c6dbef", maxColor: "#08306b", minValue: 30, maxValue: 90, displayColor: "#aec7e8" },
      "21AFD": { winnerColor: "#ff7f0e", minColor: "#fee6ce", maxColor: "#e6550d", minValue: 0, maxValue: 40, displayColor: "#fdae6b" },
      "21GRUENE": { winnerColor: "#2ca02c", minColor: "#c7e9c0", maxColor: "#006d2c", minValue: 0, maxValue: 50, displayColor: "#98df8a" },
      "21LINKE": { winnerColor: "#d62728", minColor: "#fcbba1", maxColor: "#99000d", minValue: 0, maxValue: 30, displayColor: "#ff9896" },
      "21VOLT": { winnerColor: "#9467bd", minColor: "#e7e1ef", maxColor: "#54278f", minValue: 0, maxValue: 20, displayColor: "#c5b0d5" },
      "21SPD": { winnerColor: "#8c564b", minColor: "#f4e6d1", maxColor: "#7f2704", minValue: 0, maxValue: 40, displayColor: "#c49c94" },
      "21PMUT": { winnerColor: "#e377c2", minColor: "#fde0dd", maxColor: "#a50f15", minValue: 0, maxValue: 10, displayColor: "#f7b6d2" },
      "21MLPD": { winnerColor: "#7f7f7f", minColor: "#d9d9d9", maxColor: "#525252", minValue: 0, maxValue: 5, displayColor: "#c7c7c7" },
      "21FW": { winnerColor: "#bcbd22", minColor: "#e7e9a9", maxColor: "#8c8c00", minValue: 0, maxValue: 15, displayColor: "#dbdb8d" },
      "21FDP": { winnerColor: "#17becf", minColor: "#ccece6", maxColor: "#008080", minValue: 0, maxValue: 25, displayColor: "#9edae5" },
      "21CDU": { winnerColor: "#393b79", minColor: "#dcdcdc", maxColor: "#252525", minValue: 0, maxValue: 60, displayColor: "#637939" },
      "25WAHLBETEILIGUNG": { winnerColor: "#1f77b4", minColor: "#c6dbef", maxColor: "#08306b", minValue: 30, maxValue: 90, displayColor: "#aec7e8" },
      "25AFD": { winnerColor: "#ff7f0e", minColor: "#fee6ce", maxColor: "#e6550d", minValue: 0, maxValue: 40, displayColor: "#fdae6b" },
      "25GRUENE": { winnerColor: "#2ca02c", minColor: "#c7e9c0", maxColor: "#006d2c", minValue: 0, maxValue: 50, displayColor: "#98df8a" },
      "25LINKE": { winnerColor: "#d62728", minColor: "#fcbba1", maxColor: "#99000d", minValue: 0, maxValue: 30, displayColor: "#ff9896" },
      "25VOLT": { winnerColor: "#9467bd", minColor: "#e7e1ef", maxColor: "#54278f", minValue: 0, maxValue: 20, displayColor: "#c5b0d5" },
      "25SPD": { winnerColor: "#8c564b", minColor: "#f4e6d1", maxColor: "#7f2704", minValue: 0, maxValue: 40, displayColor: "#c49c94" },
      "25PMUT": { winnerColor: "#e377c2", minColor: "#fde0dd", maxColor: "#a50f15", minValue: 0, maxValue: 10, displayColor: "#f7b6d2" },
      "25MLPD": { winnerColor: "#7f7f7f", minColor: "#d9d9d9", maxColor: "#525252", minValue: 0, maxValue: 5, displayColor: "#c7c7c7" },
      "25FW": { winnerColor: "#bcbd22", minColor: "#e7e9a9", maxColor: "#8c8c00", minValue: 0, maxValue: 15, displayColor: "#dbdb8d" },
      "25FDP": { winnerColor: "#17becf", minColor: "#ccece6", maxColor: "#008080", minValue: 0, maxValue: 25, displayColor: "#9edae5" },
      "25CDU": { winnerColor: "#393b79", minColor: "#dcdcdc", maxColor: "#252525", minValue: 0, maxValue: 60, displayColor: "#637939" },
      "25BSW": { winnerColor: "#7cb342", minColor: "#dcedc8", maxColor: "#33691e", minValue: 0, maxValue: 15, displayColor: "#aed581" }
    };

    // Globale Variablen
    let electionData = {};   // CSV-Daten, indexiert nach ID
    let berlinAggregated = {}; // Aggregierte Werte für ganz Berlin
    let selectedFeatureId = null;
    let barChart; // Chart.js-Instanz

    /********************
     * Map initialisieren *
     ********************/
    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://kxljxv.github.io/bm_web_gry_7.json', // modifizierte Basemap vor der GeoJSON-Ebene
      center: [13.4050, 52.5200], // Berlin-Zentrum
      zoom: 10,
      dragRotate: false,
      touchZoomRotate: false,
      pitchWithRotate: false
    });

    // Standard-Maplibre Buttons: Zoom + Standort
    map.addControl(new maplibregl.NavigationControl());
    map.addControl(new maplibregl.GeolocateControl({
      positionOptions: { enableHighAccuracy: true },
      trackUserLocation: true
    }));

    map.on('load', function() {
      // GeoJSON-Quelle hinzufügen
      map.addSource('wahlergebnisse', {
        type: 'geojson',
        data: 'https://kxljxv.github.io/wahlergebnisse/map.json'
      });

      // Damit Feature States funktionieren, stellen wir sicher, dass jedes Feature eine ID hat
      const sourceData = map.getSource('wahlergebnisse')._data;
      sourceData.features.forEach(function(feature) {
        feature.id = feature.properties.ID;
      });

      // Layer für die Füllung der Polygone (ohne Umrandung)
      map.addLayer({
        id: 'wahlergebnisse-fill',
        type: 'fill',
        source: 'wahlergebnisse',
        layout: {},
        paint: {
          // Zunächst ein Standardwert; später wird in updateMapColors() überschrieben
          'fill-color': '#cccccc',
          'fill-opacity': 0.7
        }
      }, map.getStyle().layers[0].id);

      // Layer für die Umrandung des ausgewählten Wahlbezirks
      map.addLayer({
        id: 'wahlergebnisse-border',
        type: 'line',
        source: 'wahlergebnisse',
        layout: {},
        paint: {
          'line-color': '#000000',
          'line-width': 2
        },
        filter: ['==', 'ID', ''] // zunächst kein Feature ausgewählt
      });

      // CSV-Daten laden und parsen
      fetch('https://kxljxv.github.io/wahlergebnisse/ergebnisse.csv')
        .then(response => response.text())
        .then(csvText => {
          const rows = csvText.split('\n').filter(line => line.trim() !== '');
          const headers = rows[0].split(',');
          rows.slice(1).forEach(line => {
            const cols = line.split(',');
            let rowObj = {};
            headers.forEach((h, i) => {
              rowObj[h.trim()] = cols[i] ? cols[i].trim() : "";
            });
            // Daten indexieren nach ID
            electionData[rowObj["ID"]] = rowObj;
          });
          // Aggregation für ganz Berlin (z. B. arithmetisches Mittel)
          computeBerlinAggregated();
          // Karte und Diagramm initial stylen
          updateMapColors();
          updateChart(berlinAggregated);
        });
    });

    /********************
     * Funktionen *
     ********************/
    // Aggregiert alle numerischen Spalten über Berlin
    function computeBerlinAggregated() {
      let sum = {}, count = {};
      for (let id in electionData) {
        const data = electionData[id];
        for (let key in data) {
          const num = parseFloat(data[key]);
          if (!isNaN(num)) {
            sum[key] = (sum[key] || 0) + num;
            count[key] = (count[key] || 0) + 1;
          }
        }
      }
      for (let key in sum) {
        berlinAggregated[key] = sum[key] / count[key];
      }
    }

    // Aktualisiert die Farben der Polygone gemäß der Auswahl
    function updateMapColors() {
      const wahljahr = document.getElementById('wahljahr').value;
      const ergebnissart = document.getElementById('ergebnissart').value;

      if (ergebnissart === 'gewinner') {
        // Für jedes Feature: Gewinner anhand der entsprechenden Parteiergebnisse berechnen
        const features = map.getSource('wahlergebnisse')._data.features;
        features.forEach(feature => {
          const id = feature.properties.ID;
          const data = electionData[id];
          if (data) {
            let prefix = wahljahr;
            let maxVal = -Infinity;
            let winner = null;
            // Durchlaufe alle Spalten, die mit dem Jahr beginnen und relevante Parteien enthalten
            for (let key in data) {
              if (key.startsWith(prefix) &&
                  key !== prefix + "WAHLBETEILIGUNG" &&
                  key !== prefix + "UWB") {
                const val = parseFloat(data[key]);
                if (val > maxVal) {
                  maxVal = val;
                  winner = key;
                }
              }
            }
            const color = (winner && columnConfig[winner]) ? columnConfig[winner].winnerColor : '#cccccc';
            map.setFeatureState({ source: 'wahlergebnisse', id: feature.id }, { fillColor: color });
          }
        });
        // Verwende im Style die per Feature State gesetzte Farbe
        map.setPaintProperty('wahlergebnisse-fill', 'fill-color', [
          'case',
          ['boolean', ['feature-state', 'selected'], false],
          '#000000',
          ['feature-state', 'fillColor']
        ]);
      } else {
        // Normale Farbabstufung: Interpoliert zwischen Minimal- und Maximalfarbe
        const configItem = columnConfig[ergebnissart];
        if (configItem) {
          map.setPaintProperty('wahlergebnisse-fill', 'fill-color', [
            'interpolate', ['linear'],
            ['to-number', ['get', ergebnissart]],
            configItem.minValue, configItem.minColor,
            configItem.maxValue, configItem.maxColor
          ]);
        }
      }
    }

    // Aktualisiert das Balkendiagramm (zeigt entweder aggregierte Berliner Daten oder Daten eines ausgewählten Bezirks)
    function updateChart(data) {
      const wahljahr = document.getElementById('wahljahr').value;
      const parties = [];
      const values = [];
      const colors = [];
      const labels = [];

      // Gehe alle Spalten des Datensatzes durch und filtere die für das jeweilige Jahr
      for (let key in data) {
        if (key.startsWith(wahljahr) &&
            key !== wahljahr + "WAHLBETEILIGUNG" &&
            key !== wahljahr + "UWB") {
          parties.push(key);
          values.push(parseFloat(data[key]) || 0);
          colors.push((columnConfig[key]) ? columnConfig[key].displayColor : '#888888');
          // Kürze das Label, z. B. "21AFD" → "AFD"
          labels.push(key.replace(wahljahr, ''));
        }
      }
      // Update Infozeile über dem Diagramm
      document.getElementById('districtID').innerText = data["ID"] || "Berlin";
      document.getElementById('bezirkName').innerText = data["BEZIRK"] || "Gesamt Berlin";

      const ctx = document.getElementById('barChart').getContext('2d');
      if (barChart) {
        barChart.destroy();
      }
      barChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Ergebnis in %',
            data: values,
            backgroundColor: colors
          }]
        },
        options: {
          scales: {
            y: {
              beginAtZero: true,
              max: 100
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  return context.parsed.y + '%';
                }
              }
            }
          }
        }
      });
    }

    /********************
     * Interaktion *
     ********************/
    // Aktualisiere Karte und Diagramm bei Änderung der Steuerung
    document.getElementById('wahljahr').addEventListener('change', function() {
      updateMapColors();
      updateChart(berlinAggregated);
    });
    document.getElementById('ergebnissart').addEventListener('change', function() {
      updateMapColors();
      updateChart(berlinAggregated);
    });
    document.getElementById('mode').addEventListener('change', function() {
      document.body.className = this.value;
    });

    // Beim Klick auf ein Polygon: Umrandung hervorheben und Diagramm mit Bezirksdaten aktualisieren
    map.on('click', 'wahlergebnisse-fill', function(e) {
      const feature = e.features[0];
      selectedFeatureId = feature.properties.ID;
      // Setze den Filter der Border-Layer, sodass nur das ausgewählte Feature umrissen wird
      map.setFilter('wahlergebnisse-border', ['==', 'ID', selectedFeatureId]);
      const data = electionData[selectedFeatureId];
      if (data) {
        updateChart(data);
      }
    });

    // Optional: Klick außerhalb eines Polygons setzt die Auswahl zurück
    map.on('click', function(e) {
      const features = map.queryRenderedFeatures(e.point, { layers: ['wahlergebnisse-fill'] });
      if (!features.length) {
        selectedFeatureId = null;
        map.setFilter('wahlergebnisse-border', ['==', 'ID', '']);
        updateChart(berlinAggregated);
      }
    });
  </script>
</body>
</html>
