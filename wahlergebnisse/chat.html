<!DOCTYPE html>
<html>
<head>
  <title>Map mit CSV-gestuftem GeoJSON</title>
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet">
  <style>
    body { margin: 0; padding: 0; }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script>
    /**
     * Erstellt eine MapLibre-Karte, lädt GeoJSON und CSV,
     * verbindet die Daten und färbt die Polygone anhand
     * eines interpolierten Wertes zwischen minValue und maxValue.
     *
     * @param {string} geojsonUrl - URL zur GeoJSON-Datei.
     * @param {string} csvUrl - URL zur CSV-Datei (Spalten: ID, tatsächlicher Wert, darzustellender Wert).
     * @param {string} minColor - Farbe, wenn der Wert minValue erreicht.
     * @param {string} maxColor - Farbe, wenn der Wert maxValue erreicht.
     * @param {number} minValue - Minimalwert für die Interpolation (z.B. 0).
     * @param {number} maxValue - Maximalwert für die Interpolation (z.B. 1).
     */
    function createMap(geojsonUrl, csvUrl, minColor, maxColor, minValue, maxValue) {
      // Karte initialisieren – basemap-style mit transparentem Hintergrund
      var map = new maplibregl.Map({
        container: 'map',
        style: 'https://kxljxv.github.io/style.json',
        center: [10, 51],
        zoom: 6
      });

      // Lade CSV und GeoJSON parallel
      Promise.all([
        fetch(csvUrl).then(response => response.text()),
        fetch(geojsonUrl).then(response => response.json())
      ])
      .then(([csvText, geojsonData]) => {
        // CSV parsen – Annahme: Erste Zeile enthält Header
        // Spalten: 0: ID, 1: tatsächlicher Wert, 2: darzustellender Wert
        var csvMapping = {};
        var lines = csvText.trim().split('\n');
        for (var i = 1; i < lines.length; i++) {
          var cols = lines[i].split(',');
          var id = cols[0].trim();
          var raw = cols[2].trim();
          // Wenn kein Dezimalpunkt enthalten ist, Wert als "0."+Wert interpretieren (z.B. "45" wird zu "0.45")
          if (raw.indexOf('.') === -1) {
            raw = "0." + raw;
          }
          var displayValue = parseFloat(raw);
          csvMapping[id] = displayValue;
        }

        // In die GeoJSON-Features den darzustellenden Wert einfügen.
        geojsonData.features.forEach(function(feature) {
          var featureId = feature.properties.ID;
          feature.properties.displayValue = csvMapping.hasOwnProperty(featureId)
            ? csvMapping[featureId]
            : minValue;
        });

        // Nach Laden der Karte die GeoJSON-Daten als Quelle und Layer hinzufügen.
        map.on('load', function() {
          map.addSource('geojson-layer', {
            type: 'geojson',
            data: geojsonData
          });
          
          // Fügt die Ebene unter der ersten Basemap-Ebene ein.
          var firstLayerId = map.getStyle().layers[0].id;
          map.addLayer({
            id: 'geojson-fill',
            type: 'fill',
            source: 'geojson-layer',
            layout: {},
            paint: {
              // Interpolation: Bei minValue wird minColor genutzt, bei maxValue maxColor.
              'fill-color': [
                'interpolate',
                ['linear'],
                ['coalesce', ['get', 'displayValue'], minValue],
                minValue, minColor,
                maxValue, maxColor
              ],
              'fill-opacity': 0.5
            }
          }, firstLayerId);
        });
      })
      .catch(error => console.error('Fehler beim Laden der Daten:', error));
    }

    // Funktionsaufruf mit den gewünschten Eingaben:
    createMap(
      'https://kxljxv.github.io/wahlergebnisse/wahlergebnisse2025nurID.json',
      'https://kxljxv.github.io/wahlergebnisse/wahlbeteiligung2025commasep.csv',
      '#00FF00',  // Minimalfarbe (z. B. Grün)
      '#FF0000',  // Maximalfarbe (z. B. Rot)
      0,          // Minimalwert
      1           // Maximalwert
    );
  </script>
</body>
</html>
