<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wahlergebnisse Karte</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
  <!-- Leaflet Control Geocoder CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
  <!-- Leaflet Locate CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-locatecontrol/0.79.0/L.Control.Locate.min.css" />
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f4f4f4;
    }
    #map {
      width: 80%;
      height: 70vh;
      margin: 20px 0;
      border-radius: 10px;
      box-shadow: 0 0 15px rgba(0,0,0,0.1);
    }
    h1 {
      font-size: 2em;
      margin-top: 30px;
      text-align: center;
      color: #333;
    }
    p.description {
      font-size: 1.1em;
      text-align: center;
      max-width: 800px;
      margin-top: 15px;
      color: #555;
    }
    .controls {
      margin-top: 20px;
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
    }
    select {
      padding: 10px;
      font-size: 1em;
      border-radius: 5px;
      border: 1px solid #ccc;
    }
    label {
      font-size: 1em;
      color: #333;
    }
    .color-picker {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    input[type="color"] {
      border: none;
      padding: 0;
      width: 30px;
      height: 30px;
      border-radius: 3px;
      cursor: pointer;
    }
    .color-label {
      display: flex;
      flex-direction: column;
      font-size: 0.8em;
    }
  </style>
</head>
<body>
  <h1>Wahlergebnisse in Berlin</h1>
  <p class="description">
    In diesen Karten sind die Urnen- und Briefwahlergebnisse auf Urnenwahlbezirksebene visualisiert.
  </p>

  <!-- Steuerung: Wahljahr und Partei-Auswahl -->
  <div class="controls">
    <div>
      <label for="datasetSelect">Wahljahr:</label>
      <select id="datasetSelect">
        <option value="2025" selected>2025</option>
        <option value="2021">2021</option>
      </select>
    </div>
    <div>
      <label for="partySelect">Partei:</label>
      <select id="partySelect"></select>
    </div>
    <div class="color-picker">
      <div class="color-label">
        <label for="minColor">Min Farbe:</label>
        <input type="color" id="minColor" value="#ffffff">
      </div>
      <div class="color-label">
        <label for="maxColor">Max Farbe:</label>
        <input type="color" id="maxColor" value="#000000">
      </div>
    </div>
  </div>

  <!-- Karte -->
  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  <!-- Leaflet Control Geocoder JS -->
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
  <!-- Leaflet Locate JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-locatecontrol/0.79.0/L.Control.Locate.min.js"></script>
  <script>
    L.Polyline.prototype.options.smoothFactor = 0;
    // Mapping für Anzeige-Namen der Parteien (funktioniert für beide Datensätze)
    var partyDisplayNames = {
      "WahlbeteiligunginkBW": "Wahlbeteiligung",
      "SPDinkBW": "SPD",
      "GrueninkBW": "Grüne",
      "CDUinkBW": "CDU",
      "LINKEinkBW": "Die Linke",
      "LinkeinkBW": "Die Linke",
      "AfDinkBW": "AfD",
      "FDPinkBW": "FDP",
      "BSWinkBWB": "BSW",
      "PARTEIMENSCHUMWELTTIERSCHUTZinkBW": "Tierschutzpartei",
      "VoltDeutschlandinkBW": "Volt",
      "VoltinkBW": "Volt",
      "FWinkBW": "FW",
      "MLPDinkBW": "MLPD"
    };

    // Mapping zwischen ähnlichen Parteibezeichnungen für 2021 und 2025
    var partyMapping = {
      // 2025 -> 2021
      "LINKEinkBW": "LinkeinkBW",
      "VoltDeutschlandinkBW": "VoltinkBW",
      // 2021 -> 2025
      "LinkeinkBW": "LINKEinkBW",
      "VoltinkBW": "VoltDeutschlandinkBW"
    };

    // Farbpaare für die Parteien (Min- und Max-Farben)
    var partyColors = {
      "WahlbeteiligunginkBW": { min: "#E0B4AB", max: "#042c1c" },
      "SPDinkBW": { min: "#C3E3CB", max: "#e3010f" },
      "GrueninkBW": { min: "#EDCCDD", max: "#009e00" },
      "CDUinkBW": { min: "#EEE2CB", max: "#151518" },
      "LINKEinkBW": { min: "#C2EBBC", max: "#a40372" },
      "LinkeinkBW": { min: "#C2EBBC", max: "#a40372" },
      "AfDinkBW": { min: "#F0E4CC", max: "#0047C2" },
      "FDPinkBW": { min: "#A1A4C2", max: "#C29800" },
      "BSWinkBWB": { min: "#BDDBBD", max: "#67173e" },
      "PARTEIMENSCHUMWELTTIERSCHUTZinkBW": { min: "#E6D7CC", max: "#00555f" },
      "VoltDeutschlandinkBW": { min: "#D4D3BA", max: "#4c247a" },
      "VoltinkBW": { min: "#D4D3BA", max: "#4c247a" },
      "FWinkBW": { min: "#D2F5FC", max: "#ff7800" },
      "MLPDinkBW": { min: "#CDF7D5", max: "#b01935" }
    };

    // Datensatz 2025 (wie bisher)
    var dataset2025 = {
      url: 'https://kxljxv.github.io/wahlergebnisse2025.json',
      partyRanges: {
        "WahlbeteiligunginkBW": { min: 0.5, max: 0.96 },
        "SPDinkBW": { min: 0.06, max: 0.26 },
        "GrueninkBW": { min: 0.015, max: 0.41 },
        "CDUinkBW": { min: 0.031, max: 0.46 },
        "LINKEinkBW": { min: 0.04, max: 0.5 },
        "AfDinkBW": { min: 0.02, max: 0.5 },
        "FDPinkBW": { min: 0.004, max: 0.16 },
        "BSWinkBWB": { min: 0.012, max: 0.16 },    
        "PARTEIMENSCHUMWELTTIERSCHUTZinkBW": { min: 0.0, max: 0.057 },  
        "VoltDeutschlandinkBW": { min: 0.0, max: 0.029 },  
        "FWinkBW": { min: 0.0, max: 0.017 },  
        "MLPDinkBW": { min: 0.0, max: 0.009 }  
      },
      availableParties: [
        "WahlbeteiligunginkBW", "SPDinkBW", "GrueninkBW", "CDUinkBW", "LINKEinkBW",
        "AfDinkBW", "FDPinkBW", "BSWinkBWB", "PARTEIMENSCHUMWELTTIERSCHUTZinkBW",
        "VoltDeutschlandinkBW", "FWinkBW", "MLPDinkBW"
      ]
    };

    // Datensatz 2021 (angepasst an die in 2021 vorhandenen Schlüssel)
    var dataset2021 = {
      url: 'https://kxljxv.github.io/wahlergebnisse2021.json',
      partyRanges: {
        "WahlbeteiligunginkBW": { min: 0.454105275, max: 1 },
        "SPDinkBW": { min: 0.110996917, max: 0.39984263 },
        "GrueninkBW": { min: 0.030045343, max: 0.541414141 },
        "CDUinkBW": { min: 0.025714286, max: 0.430626927 },
        "LinkeinkBW": { min: 0.011583012, max: 0.313521545 },
        "AfDinkBW": { min: 0.005931198, max: 0.282779584 },
        "FDPinkBW": { min: 0.015686275, max: 0.268841395 },
        "PARTEIMENSCHUMWELTTIERSCHUTZinkBW": { min: 0.002724796, max: 0.085704944 },  
        "VoltinkBW": { min: 0.0, max: 0.020571429 },  
        "FWinkBW": { min: 0.0, max: 0.034937014 },  
        "MLPDinkBW": { min: 0.0, max: 0.012658228 }  
      },
      availableParties: [
        "WahlbeteiligunginkBW", "SPDinkBW", "GrueninkBW", "CDUinkBW", "LinkeinkBW",
        "AfDinkBW", "FDPinkBW", "PARTEIMENSCHUMWELTTIERSCHUTZinkBW",
        "VoltinkBW", "FWinkBW", "MLPDinkBW"
      ]
    };

    // Aktueller Datensatz (initial 2025)
    var currentDataset = dataset2025;
    var currentParty = "WahlbeteiligunginkBW"; // Standardpartei
    var geojsonLayer; // Referenz zum aktuellen GeoJSON-Layer
    var userCustomColors = {}; // Speichert benutzerdefinierte Farben für Parteien

    // Hilfsfunktionen zur Farbinterpolation
    function hexToRgb(hex) {
      hex = hex.replace(/^#/, '');
      if(hex.length === 3) {
        hex = hex.split('').map(function(c) { return c + c; }).join('');
      }
      var bigint = parseInt(hex, 16);
      return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
    }
    
    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b)
          .toString(16).slice(1).toUpperCase();
    }
    
    function interpolateColor(minColor, maxColor, value) {
      var minRgb = hexToRgb(minColor);
      var maxRgb = hexToRgb(maxColor);
      
      var r = Math.round(minRgb.r + (maxRgb.r - minRgb.r) * value);
      var g = Math.round(minRgb.g + (maxRgb.g - minRgb.g) * value);
      var b = Math.round(minRgb.b + (maxRgb.b - minRgb.b) * value);
      
      return rgbToHex(r, g, b);
    }
    
    function getColor(rawValue, party) {
      var range = currentDataset.partyRanges[party];
      var normalized = (rawValue - range.min) / (range.max - range.min);
      normalized = Math.max(0, Math.min(1, normalized));
      
      // Benutze benutzerdefinierte Farben, wenn vorhanden, sonst die Standardfarben
      var minColor = userCustomColors[party] ? 
                    userCustomColors[party].min : 
                    partyColors[party].min;
      var maxColor = userCustomColors[party] ? 
                    userCustomColors[party].max : 
                    partyColors[party].max;
      
      return interpolateColor(minColor, maxColor, normalized);
    }
  
    // Polygon-Style-Funktion
    function style(feature) {
      var rawValue = parseFloat(feature.properties[currentParty].replace(',', '.'));
      var zoom = map.getZoom();
      var opacity = 0.7 + (zoom - 12) * 0.05; // Dynamische Transparenz
      return {
        fillColor: getColor(rawValue, currentParty),
        weight: 0,
        opacity: 1,
        color: 'transparent',
        fillOpacity: opacity
      };
    }
  
    // Popup und Ereignisse für Polygone
    function onEachFeature(feature, layer) {
      layer.on({
        click: function(e) {
          var rawValue = parseFloat(feature.properties[currentParty].replace(',', '.'));
          var percent = (rawValue * 100).toFixed(2) + '%';
          var popupContent = '<b>' + feature.properties.UWB + '</b><br>' +
            'Wahlbeteiligung: ' + (parseFloat(feature.properties.WahlbeteiligunginkBW.replace(',', '.')) * 100).toFixed(2) + '%<br>' +
            'Ergebnis: ' + percent + ' (' + partyDisplayNames[currentParty] + ')';
          layer.bindPopup(popupContent).openPopup();
        }
      });
    }
  
    // Kartenbegrenzungen und Basemap
    var bounds = L.latLngBounds([[52.3, 13.0], [52.7, 13.8]]);
    var map = L.map('map', {
      center: [52.52, 13.40],
      zoom: 10,
      minZoom: 9,
      maxBounds: bounds,
      inertia: false
    });
  
    var basemap = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap, CartoDB, Amt für Statistik Berlin-Brandenburg',
      maxZoom: 19,
      opacity: 0.3
    }).addTo(map);
  
    map.on('zoomend', function() {
      var zoom = map.getZoom();
  
      // Je weiter herausgezoomt, desto blasser die Karte
      var opacity = (zoom - 10) * 0.15;  
      opacity = Math.max(0.1, Math.min(1, opacity)); // Begrenzen zwischen 0.1 und 1

      basemap.setOpacity(opacity);
    });

  
    L.control.scale({position: 'bottomright'}).addTo(map);
  
    L.Control.geocoder({
      defaultMarkGeocode: false
    })
    .on('markgeocode', function(e) {
      var bbox = e.geocode.bbox;
      var poly = L.polygon([
        bbox.getSouthEast(),
        bbox.getNorthEast(),
        bbox.getNorthWest(),
        bbox.getSouthWest()
      ]).addTo(map);
      map.fitBounds(poly.getBounds());
    })
    .addTo(map);
    
    var lc = L.control.locate({
      position: 'topleft',
      strings: {
        title: "Meinen Standort anzeigen",
        popup: "Sie befinden sich innerhalb von {distance} {unit} von diesem Punkt entfernt",
        outsideMapBoundsMsg: "Sie scheinen sich außerhalb der Kartengrenzen zu befinden"
      },
      locateOptions: {
        maxZoom: 16,
        enableHighAccuracy: true
      },
      icon: 'fa fa-map-marker',
      showPopup: true,
      onLocationError: function(err) {
        alert("Standorterfassung fehlgeschlagen: " + err.message);
      },
      onLocationOutsideMapBounds: function(context) {
        alert("Sie befinden sich außerhalb des kartierten Bereichs von Berlin!");
      }
    }).addTo(map);
  
    // Funktion zum Laden des aktuellen GeoJSON-Datensatzes
    function loadGeoJson() {
      fetch(currentDataset.url)
        .then(response => response.json())
        .then(data => {
          if (geojsonLayer) {
            map.removeLayer(geojsonLayer);
          }
          geojsonLayer = L.geoJSON(data, {
            style: style,
            onEachFeature: onEachFeature,
            smoothFactor: 0,  // Erzwingt maximale Details ohne Vereinfachung
            noClip: true       // Verhindert Abschneiden am Rand
          }).addTo(map);
        })
        .catch(error => console.error('Fehler beim Laden der GeoJSON-Daten:', error));
    }

    // Prüft, ob eine Partei im aktuellen Datensatz verfügbar ist
    function isPartyAvailable(party, dataset) {
      return dataset.availableParties.includes(party);
    }

    // Sucht nach einer entsprechenden Partei im anderen Datensatz
    function findEquivalentParty(party, targetDataset) {
      // Direktes Mapping prüfen
      if (partyMapping[party] && isPartyAvailable(partyMapping[party], targetDataset)) {
        return partyMapping[party];
      }
      
      // Prüfen, ob die Partei unverändert im Zieldatensatz verfügbar ist
      if (isPartyAvailable(party, targetDataset)) {
        return party;
      }
      
      // Standardpartei zurückgeben, wenn keine Entsprechung gefunden wurde
      return "WahlbeteiligunginkBW";
    }
  
    // Funktion zum Aufbau des Partei-Dropdowns anhand des aktuellen Datensatzes
    function populatePartySelect() {
      var partySelect = document.getElementById('partySelect');
      var currentValue = partySelect.value; // Aktuelle Auswahl speichern
      
      partySelect.innerHTML = "";
      currentDataset.availableParties.forEach(function(key) {
        var option = document.createElement('option');
        option.value = key;
        option.text = partyDisplayNames[key] || key;
        partySelect.appendChild(option);
      });
      
      // Versuchen, die vorherige Auswahl beizubehalten oder eine entsprechende Partei zu finden
      if (currentValue && isPartyAvailable(currentValue, currentDataset)) {
        partySelect.value = currentValue;
        currentParty = currentValue;
      } else if (currentValue) {
        // Versuchen, eine äquivalente Partei zu finden
        var equivalentParty = findEquivalentParty(currentValue, currentDataset);
        partySelect.value = equivalentParty;
        currentParty = equivalentParty;
      } else {
        // Standardpartei setzen, wenn keine vorherige Auswahl vorhanden
        currentParty = partySelect.value;
      }
      
      // Farbpicker mit aktuellen Farben für die gewählte Partei aktualisieren
      updateColorPickers();
    }

    // Funktion zum Aktualisieren der Farbpicker basierend auf der aktuellen Partei
    function updateColorPickers() {
      var minColorPicker = document.getElementById('minColor');
      var maxColorPicker = document.getElementById('maxColor');
      
      // Wenn benutzerdefinierte Farben für diese Partei existieren, diese verwenden
      if (userCustomColors[currentParty]) {
        minColorPicker.value = userCustomColors[currentParty].min;
        maxColorPicker.value = userCustomColors[currentParty].max;
      } else {
        // Sonst die Standardfarben verwenden
        minColorPicker.value = partyColors[currentParty].min;
        maxColorPicker.value = partyColors[currentParty].max;
      }
    }
  
    // Event-Listener für Parteien-Wechsel
    document.getElementById('partySelect').addEventListener('change', function(e) {
      currentParty = e.target.value;
      updateColorPickers();
      if (geojsonLayer) {
        geojsonLayer.setStyle(style);
      }
    });
  
    // Event-Listener für Datensatz-Wechsel
    document.getElementById('datasetSelect').addEventListener('change', function(e) {
      var selectedYear = e.target.value;
      var previousParty = currentParty; // Speichern der aktuellen Parteiauswahl
      
      if (selectedYear === "2025") {
        currentDataset = dataset2025;
      } else if (selectedYear === "2021") {
        currentDataset = dataset2021;
      }
      
      // Parteiauswahl aktualisieren und dabei die vorherige Auswahl berücksichtigen
      populatePartySelect();
      loadGeoJson();
    });
    
    // Event-Listener für Farbpicker
    document.getElementById('minColor').addEventListener('change', function(e) {
      if (!userCustomColors[currentParty]) {
        userCustomColors[currentParty] = {
          min: partyColors[currentParty].min,
          max: partyColors[currentParty].max
        };
      }
      userCustomColors[currentParty].min = e.target.value;
      if (geojsonLayer) {
        geojsonLayer.setStyle(style);
      }
    });
    
    document.getElementById('maxColor').addEventListener('change', function(e) {
      if (!userCustomColors[currentParty]) {
        userCustomColors[currentParty] = {
          min: partyColors[currentParty].min,
          max: partyColors[currentParty].max
        };
      }
      userCustomColors[currentParty].max = e.target.value;
      if (geojsonLayer) {
        geojsonLayer.setStyle(style);
      }
    });
  
    // Initialer Aufbau
    populatePartySelect();
    loadGeoJson();
  </script>
</body>
</html>
